1. What is undefined behavior?
Undefined behavior means:
The C/C++ standard gives no guarantee about what happens

Examples:
Accessing out-of-bounds array
Using uninitialized variable
Dereferencing NULL pointer
Accessing freed memory
Integer overflow (signed)

int a[5];
a[10] = 3;  // âŒ UB

â¡ï¸ Program may:
Crash
Produce wrong output
Work â€œsometimesâ€ (dangerous!)

2. Dangling Pointer
A dangling pointer points to memory that has already been freed or gone out of scope.
int *p = (int*)malloc(sizeof(int));
free(p);
// p is now dangling
*p = 10;  // âŒ undefined behavior

Causes:
Access after free()
Returning address of local variable
Object deleted but pointer not reset

Fix:
free(p);
p = NULL;

3. What Happens If You Access Freed Memory?

This is undefined behavior.
int *p = new int(10);
delete p;
*p = 20;   // âŒ UB

Possible outcomes:
Crash (segmentation fault)
Corrupt heap
Silent bugs
Security vulnerability

Best Practice:
delete p;
p = nullptr;

4. Memory Leak
A memory leak occurs when allocated memory is never freed, causing memory loss over time.

void leak() {
    int *p = new int(10);
    // delete p missing âŒ
}

Effects:
Increased memory usage
Program slowdown
System crash (embedded systems)

Detection Tools:
Valgrind (Linux)
AddressSanitizer (ASAN)
Visual Studio Leak Detector
Static analysis tools

5.struct vs union
Feature	struct	                    union
Memory	Separate for each member	Shared
Size	Sum of members (+ padding)	Size of largest member
Access	All members valid	Only one at a time
union U {
    int i;
    float f;
};

â¡ï¸ Writing to f overwrites i
Use cases:
struct â†’ logical grouping
union â†’ memory optimization, hardware registers


6. Structure Padding & Alignment
Why padding exists:
CPU accesses aligned memory faster
Compiler inserts unused bytes

struct A {
    char c;   // 1 byte
    int i;    // 4 bytes
};

Memory layout (32-bit / 64-bit):
| c | pad pad pad | i |

Size = 8 bytes, not 5
Control padding
#pragma pack(1)

7. Where does malloc get memory from?
On Linux / Unix:

malloc() does not directly ask the OS for every allocation.
Instead, it requests large chunks from the OS using:
brk()/sbrk() â†’ grows the process heap (small/medium allocations)
mmap() â†’ large allocations (e.g., >128 KB in glibc)
These chunks form the heap arena managed by malloc.

malloc() is a dynamic memory allocator. Internally, it manages a large pool of heap memory and hands out 
chunks on request. The exact implementation differs (glibc, jemalloc, tcmalloc, RTOS allocators), 
but the core principles are the same.
Internally:
Requests large memory chunks from the OS (brk/sbrk or mmap)
Splits them into blocks with metadata (size, status)
Maintains free lists / bins for different sizes

On allocation:
Adjusts size + alignment
Finds a suitable free block
Splits it if larger

On free():
Marks block free
Coalesces adjacent free blocks to reduce fragmentation
Returned pointer points after metadata, not to raw OS memory.

ğŸ“Œ Key point: execution time and allocation success are non-deterministic

8) What is volatile and when does it fail?
volatile tells the compiler:
â€œThis variable may change unexpectedly â€” donâ€™t optimize accesses.â€
Used for:
Hardware registers
ISR-shared variables
Memory-mapped I/O
When volatile fails:
âŒ It does not ensure atomicity
âŒ It does not ensure thread safety
âŒ It does not prevent race conditions
âŒ It does not provide memory ordering

Example failure:
volatile int counter;
counter++; // NOT atomic

ğŸ‘‰ Must combine volatile with mutex, atomic ops, or critical sections.

9)Why is dynamic memory risky in safety-critical systems?
Dynamic memory is risky because it breaks determinism and reliability.
Major risks:
âŒ Unpredictable allocation time
âŒ Fragmentation â†’ allocation failures at runtime
âŒ Memory leaks
âŒ Heap corruption (use-after-free, double free)
âŒ Difficult to certify and test

Result:
System may fail after hours or days, which is unacceptable in safety systems.

10) What happens if memory gets fragmented?
Fragmentation occurs when free memory exists but not contiguously.
Effects:
malloc() fails even though total free memory is sufficient
Increased allocation time
System instability over long runtime
Example:
[Free 10B][Used][Free 20B][Used][Free 15B]
Request = 30B â†’ âŒ fails

ğŸ‘‰ External fragmentation is the main concern in embedded systems.

11) Stack vs Heap vs Static Memory â€” when to use what?
Memory Type	      Characteristics	               When to Use
Stack	          Fast, automatic, limited size	   Local variables, function calls
Heap	          Flexible, dynamic, slow	       Variable-size data, optional features
Static / Global	  Fixed, predictable	           Config, buffers, RTOS objects

12) How do you ensure deterministic behavior?
Determinism means bounded and predictable execution time.

Key techniques:
Avoid dynamic allocation at runtime
Use static allocation or memory pools
Fixed task priorities (RTOS)
Bounded loops and ISRs
WCET analysis
Avoid recursion
Use priority inheritance
Pre-allocate all resources at startup
Determinism is mandatory in real-time and safety systems.
