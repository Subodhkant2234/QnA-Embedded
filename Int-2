1. What is undefined behavior?
Undefined behavior means:
The C/C++ standard gives no guarantee about what happens

Examples:
Accessing out-of-bounds array
Using uninitialized variable
Dereferencing NULL pointer
Accessing freed memory
Integer overflow (signed)

int a[5];
a[10] = 3;  // ❌ UB

➡️ Program may:
Crash
Produce wrong output
Work “sometimes” (dangerous!)

2. Dangling Pointer
A dangling pointer points to memory that has already been freed or gone out of scope.
int *p = (int*)malloc(sizeof(int));
free(p);
// p is now dangling
*p = 10;  // ❌ undefined behavior

Causes:
Access after free()
Returning address of local variable
Object deleted but pointer not reset

Fix:
free(p);
p = NULL;

3. What Happens If You Access Freed Memory?

This is undefined behavior.
int *p = new int(10);
delete p;
*p = 20;   // ❌ UB

Possible outcomes:
Crash (segmentation fault)
Corrupt heap
Silent bugs
Security vulnerability

Best Practice:
delete p;
p = nullptr;

4. Memory Leak
A memory leak occurs when allocated memory is never freed, causing memory loss over time.

void leak() {
    int *p = new int(10);
    // delete p missing ❌
}

Effects:
Increased memory usage
Program slowdown
System crash (embedded systems)

Detection Tools:
Valgrind (Linux)
AddressSanitizer (ASAN)
Visual Studio Leak Detector
Static analysis tools

5.struct vs union
Feature	struct	                    union
Memory	Separate for each member	Shared
Size	Sum of members (+ padding)	Size of largest member
Access	All members valid	Only one at a time
union U {
    int i;
    float f;
};

➡️ Writing to f overwrites i
Use cases:
struct → logical grouping
union → memory optimization, hardware registers
