1. What is undefined behavior?
Undefined behavior means:
The C/C++ standard gives no guarantee about what happens

Examples:
Accessing out-of-bounds array
Using uninitialized variable
Dereferencing NULL pointer
Accessing freed memory
Integer overflow (signed)

int a[5];
a[10] = 3;  // ❌ UB

➡️ Program may:
Crash
Produce wrong output
Work “sometimes” (dangerous!)

2. Dangling Pointer
A dangling pointer points to memory that has already been freed or gone out of scope.
int *p = (int*)malloc(sizeof(int));
free(p);
// p is now dangling
*p = 10;  // ❌ undefined behavior

Causes:
Access after free()
Returning address of local variable
Object deleted but pointer not reset

Fix:
free(p);
p = NULL;

3. What Happens If You Access Freed Memory?

This is undefined behavior.
int *p = new int(10);
delete p;
*p = 20;   // ❌ UB

Possible outcomes:
Crash (segmentation fault)
Corrupt heap
Silent bugs
Security vulnerability

Best Practice:
delete p;
p = nullptr;

4. Memory Leak
A memory leak occurs when allocated memory is never freed, causing memory loss over time.

void leak() {
    int *p = new int(10);
    // delete p missing ❌
}

Effects:
Increased memory usage
Program slowdown
System crash (embedded systems)

Detection Tools:
Valgrind (Linux)
AddressSanitizer (ASAN)
Visual Studio Leak Detector
Static analysis tools

5.struct vs union
Feature	struct	                    union
Memory	Separate for each member	Shared
Size	Sum of members (+ padding)	Size of largest member
Access	All members valid	Only one at a time
union U {
    int i;
    float f;
};

➡️ Writing to f overwrites i
Use cases:
struct → logical grouping
union → memory optimization, hardware registers


6. Structure Padding & Alignment
Why padding exists:
CPU accesses aligned memory faster
Compiler inserts unused bytes

struct A {
    char c;   // 1 byte
    int i;    // 4 bytes
};

Memory layout (32-bit / 64-bit):
| c | pad pad pad | i |

Size = 8 bytes, not 5
Control padding
#pragma pack(1)

7. Where does malloc get memory from?
On Linux / Unix:

malloc() does not directly ask the OS for every allocation.
Instead, it requests large chunks from the OS using:
brk()/sbrk() → grows the process heap (small/medium allocations)
mmap() → large allocations (e.g., >128 KB in glibc)
These chunks form the heap arena managed by malloc.

malloc() is a dynamic memory allocator. Internally, it manages a large pool of heap memory and hands out 
chunks on request. The exact implementation differs (glibc, jemalloc, tcmalloc, RTOS allocators), 
but the core principles are the same.
