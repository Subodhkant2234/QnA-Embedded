1. What is undefined behavior?
Undefined behavior means:
The C/C++ standard gives no guarantee about what happens

Examples:
Accessing out-of-bounds array
Using uninitialized variable
Dereferencing NULL pointer
Accessing freed memory
Integer overflow (signed)

int a[5];
a[10] = 3;  // ‚ùå UB

‚û°Ô∏è Program may:
Crash
Produce wrong output
Work ‚Äúsometimes‚Äù (dangerous!)

2. Dangling Pointer
A dangling pointer points to memory that has already been freed or gone out of scope.
int *p = (int*)malloc(sizeof(int));
free(p);
// p is now dangling
*p = 10;  // ‚ùå undefined behavior

Causes:
Access after free()
Returning address of local variable
Object deleted but pointer not reset

Fix:
free(p);
p = NULL;

3. What Happens If You Access Freed Memory?

This is undefined behavior.
int *p = new int(10);
delete p;
*p = 20;   // ‚ùå UB

Possible outcomes:
Crash (segmentation fault)
Corrupt heap
Silent bugs
Security vulnerability

Best Practice:
delete p;
p = nullptr;

4. Memory Leak
A memory leak occurs when allocated memory is never freed, causing memory loss over time.

void leak() {
    int *p = new int(10);
    // delete p missing ‚ùå
}

Effects:
Increased memory usage
Program slowdown
System crash (embedded systems)

Detection Tools:
Valgrind (Linux)
AddressSanitizer (ASAN)
Visual Studio Leak Detector
Static analysis tools

5.struct vs union
Feature	struct	                    union
Memory	Separate for each member	Shared
Size	Sum of members (+ padding)	Size of largest member
Access	All members valid	Only one at a time
union U {
    int i;
    float f;
};

‚û°Ô∏è Writing to f overwrites i
Use cases:
struct ‚Üí logical grouping
union ‚Üí memory optimization, hardware registers


6. Structure Padding & Alignment
Why padding exists:
CPU accesses aligned memory faster
Compiler inserts unused bytes

struct A {
    char c;   // 1 byte
    int i;    // 4 bytes
};

Memory layout (32-bit / 64-bit):
| c | pad pad pad | i |

Size = 8 bytes, not 5
Control padding
#pragma pack(1)

7. Where does malloc get memory from?
On Linux / Unix:

malloc() does not directly ask the OS for every allocation.
Instead, it requests large chunks from the OS using:
brk()/sbrk() ‚Üí grows the process heap (small/medium allocations)
mmap() ‚Üí large allocations (e.g., >128 KB in glibc)
These chunks form the heap arena managed by malloc.

malloc() is a dynamic memory allocator. Internally, it manages a large pool of heap memory and hands out 
chunks on request. The exact implementation differs (glibc, jemalloc, tcmalloc, RTOS allocators), 
but the core principles are the same.
Internally:
Requests large memory chunks from the OS (brk/sbrk or mmap)
Splits them into blocks with metadata (size, status)
Maintains free lists / bins for different sizes

On allocation:
Adjusts size + alignment
Finds a suitable free block
Splits it if larger

On free():
Marks block free
Coalesces adjacent free blocks to reduce fragmentation
Returned pointer points after metadata, not to raw OS memory.

üìå Key point: execution time and allocation success are non-deterministic

8) What is volatile and when does it fail?
volatile tells the compiler:
‚ÄúThis variable may change unexpectedly ‚Äî don‚Äôt optimize accesses.‚Äù
Used for:
Hardware registers
ISR-shared variables
Memory-mapped I/O
When volatile fails:
‚ùå It does not ensure atomicity
‚ùå It does not ensure thread safety
‚ùå It does not prevent race conditions
‚ùå It does not provide memory ordering

Example failure:
volatile int counter;
counter++; // NOT atomic

üëâ Must combine volatile with mutex, atomic ops, or critical sections.

9)Why is dynamic memory risky in safety-critical systems?
Dynamic memory is risky because it breaks determinism and reliability.
Major risks:
‚ùå Unpredictable allocation time
‚ùå Fragmentation ‚Üí allocation failures at runtime
‚ùå Memory leaks
‚ùå Heap corruption (use-after-free, double free)
‚ùå Difficult to certify and test

Result:
System may fail after hours or days, which is unacceptable in safety systems.

10) What happens if memory gets fragmented?
Fragmentation occurs when free memory exists but not contiguously.
Effects:
malloc() fails even though total free memory is sufficient
Increased allocation time
System instability over long runtime
Example:
[Free 10B][Used][Free 20B][Used][Free 15B]
Request = 30B ‚Üí ‚ùå fails

üëâ External fragmentation is the main concern in embedded systems.

11) Stack vs Heap vs Static Memory ‚Äî when to use what?
Memory Type	      Characteristics	               When to Use
Stack	          Fast, automatic, limited size	   Local variables, function calls
Heap	          Flexible, dynamic, slow	       Variable-size data, optional features
Static / Global	  Fixed, predictable	           Config, buffers, RTOS objects

12) How do you ensure deterministic behavior?
Determinism means bounded and predictable execution time.

Key techniques:
Avoid dynamic allocation at runtime
Use static allocation or memory pools
Fixed task priorities (RTOS)
Bounded loops and ISRs
WCET analysis
Avoid recursion
Use priority inheritance
Pre-allocate all resources at startup
Determinism is mandatory in real-time and safety systems.

13) When is inline useful?
Use inline for small, frequently called functions where reduced call overhead improves performance, 
but avoid it when it increases code size or harms cache behavior.

inline is useful when a function is small, frequently called, and the function call overhead is significant compared to the function body.
It tells the compiler to replace the function call with the function body, which can improve performance‚Äîbut it is only a hint, not a guarantee.
When NOT to use inline:

Large or complex functions
Recursive functions
When code size matters (risk of code bloat)
When the compiler can already optimize better on its own

14) What is volatile + const use case?
const volatile is used when a variable can change outside the program‚Äôs control, but the program itself must not modify it.
volatile tells the compiler the value may change asynchronously, so it must always be re-read.
const prevents the software from writing to it.

Where it‚Äôs used:

Read-only memory-mapped hardware registers
Status flags updated by ISR, DMA, or peripherals
Safety-critical embedded systems to prevent accidental writes

Important clarification:
volatile does not make access atomic
It does not provide thread safety
It only prevents incorrect compiler optimizations

Typical example (embedded systems) : 

#define STATUS_REG (*(const volatile uint32_t*)0x40000000)
if (STATUS_REG & READY_BIT) {
    // updated by hardware
}
Here:
Hardware updates the register ‚Üí volatile
Software must only read it ‚Üí const

15) 
